#pragma once

#include <ppp/stdafx.h>
#include <ppp/threading/BufferswapAllocator.h>

namespace ppp
{
    namespace cryptography
    {
        class ssea
        {
        public:
            static void                     shuffle_data(char* encoded_data, int data_size, uint32_t key) noexcept;
            static void                     unshuffle_data(char* encoded_data, int data_size, uint32_t key) noexcept;
            static int                      delta_encode(const std::shared_ptr<ppp::threading::BufferswapAllocator>& allocator, const void* data, int data_size, int kf, std::shared_ptr<Byte>& output) noexcept;
            static int                      delta_decode(const std::shared_ptr<ppp::threading::BufferswapAllocator>& allocator, const void* data, int data_size, int kf, std::shared_ptr<Byte>& output) noexcept;
            static std::shared_ptr<Byte>    base94_encode(const std::shared_ptr<ppp::threading::BufferswapAllocator>& allocator, const void* data, int datalen, int kf, int& outlen) noexcept;
            static std::shared_ptr<Byte>    base94_decode(const std::shared_ptr<ppp::threading::BufferswapAllocator>& allocator, const void* data, int datalen, int kf, int& outlen) noexcept;
            static ppp::string              base94_decimal(uint64_t v) noexcept;
            static uint64_t                 base94_decimal(const ppp::string& v) noexcept;
            static uint64_t                 base94_decimal(const void* data, int datalen) noexcept;

        public:
            static int                      random_next(unsigned int seed) noexcept { return random_next(&seed); }
            static int                      random_next(unsigned int* seed) noexcept;
            static int                      random_next(unsigned int* seed, int min, int max) noexcept;

        public:
            static int                      lcgmod(int32_t kf, int min, int max) noexcept { return random_next((unsigned int*)&kf, min, max); }

        public:
            static bool                     masked_xor(const void* min, const void* max, int32_t kf) noexcept;
            static bool                     masked_xor_random_next(const void* min, const void* max, int32_t kf) noexcept;
        };
    }
}